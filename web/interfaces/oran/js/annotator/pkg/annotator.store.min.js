(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; }, __hasProp = Object.prototype.hasOwnProperty, __extends = function(child, parent) {
    for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; }
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor;
    child.__super__ = parent.prototype;
    return child;
  }, __indexOf = Array.prototype.indexOf || function(item) {
    for (var i = 0, l = this.length; i < l; i++) {
      if (this[i] === item) return i;
    }
    return -1;
  };
  Annotator.Plugin.Store = (function() {
    __extends(Store, Annotator.Plugin);
    Store.prototype.events = {
      'annotationCreated': 'annotationCreated',
      'annotationDeleted': 'annotationDeleted',
      'annotationUpdated': 'annotationUpdated'
    };
    Store.prototype.options = {
      prefix: '/store',
      autoFetch: true,
      annotationData: {},
      loadFromSearch: false,
      urls: {
        create: '/annotations',
        read: '/annotations/:id',
        update: '/annotations/:id',
        destroy: '/annotations/:id',
        search: '/search'
      }
    };
    function Store(element, options) {
      this._onError = __bind(this._onError, this);
      this._onBeforeSend = __bind(this._onBeforeSend, this);
      this._onLoadAnnotationsFromSearch = __bind(this._onLoadAnnotationsFromSearch, this);
      this._onLoadAnnotations = __bind(this._onLoadAnnotations, this);
      this._getAnnotations = __bind(this._getAnnotations, this);      Store.__super__.constructor.apply(this, arguments);
      this.annotations = [];
    }
    Store.prototype.pluginInit = function() {
      var auth;
      if (!Annotator.supported()) {
        return;
      }
      auth = this.element.data('annotator:auth');
      if (auth) {
        return auth.withToken(this._getAnnotations);
      } else {
        return this._getAnnotations();
      }
    };
    Store.prototype._getAnnotations = function() {
      if (this.options.loadFromSearch) {
        return this.loadAnnotationsFromSearch(this.options.loadFromSearch);
      } else {
        return this.loadAnnotations();
      }
    };
    Store.prototype.annotationCreated = function(annotation) {
      if (__indexOf.call(this.annotations, annotation) < 0) {
        this.registerAnnotation(annotation);
        return this._apiRequest('create', annotation, __bind(function(data) {
          if (!(data.id != null)) {
            console.warn("Warning: No ID returned from server for annotation ", annotation);
          }
          return this.updateAnnotation(annotation, data);
        }, this));
      } else {
        return this.updateAnnotation(annotation, {});
      }
    };
    Store.prototype.annotationUpdated = function(annotation) {
      if (__indexOf.call(this.annotations, annotation) >= 0) {
        return this._apiRequest('update', annotation, (__bind(function(data) {
          return this.updateAnnotation(annotation, data);
        }, this)));
      }
    };
    Store.prototype.annotationDeleted = function(annotation) {
      if (__indexOf.call(this.annotations, annotation) >= 0) {
        return this._apiRequest('destroy', annotation, (__bind(function() {
          return this.unregisterAnnotation(annotation);
        }, this)));
      }
    };
    Store.prototype.registerAnnotation = function(annotation) {
      return this.annotations.push(annotation);
    };
    Store.prototype.unregisterAnnotation = function(annotation) {
      return this.annotations.splice(this.annotations.indexOf(annotation), 1);
    };
    Store.prototype.updateAnnotation = function(annotation, data) {
      if (__indexOf.call(this.annotations, annotation) < 0) {
        console.error("Trying to update unregistered annotation!");
      } else {
        $.extend(annotation, data);
      }
      return $(annotation.highlights).data('annotation', annotation);
    };
    Store.prototype.loadAnnotations = function() {
      return this._apiRequest('read', null, this._onLoadAnnotations);
    };
    Store.prototype._onLoadAnnotations = function(data) {
      if (data == null) {
        data = [];
      }
      this.annotations = data;
      return this.annotator.loadAnnotations(data.slice());
    };
    Store.prototype.loadAnnotationsFromSearch = function(searchOptions) {
      return this._apiRequest('search', searchOptions, this._onLoadAnnotationsFromSearch);
    };
    Store.prototype._onLoadAnnotationsFromSearch = function(data) {
      if (data == null) {
        data = {};
      }
      return this._onLoadAnnotations(data.rows || []);
    };
    Store.prototype.dumpAnnotations = function() {
      var ann, _i, _len, _ref, _results;
      _ref = this.annotations;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ann = _ref[_i];
        _results.push(JSON.parse(this._dataFor(ann)));
      }
      return _results;
    };
    Store.prototype._apiRequest = function(action, obj, onSuccess) {
      var id, options, request, url;
      id = obj && obj.id;
      url = this._urlFor(action, id);
      options = this._apiRequestOptions(action, obj, onSuccess);
      request = $.ajax(url, options);
      request._id = id;
      request._action = action;
      return request;
    };
    Store.prototype._apiRequestOptions = function(action, obj, onSuccess) {
      var opts;
      opts = {
        type: this._methodFor(action),
        beforeSend: this._onBeforeSend,
        dataType: "json",
        success: onSuccess || function() {},
        error: this._onError
      };
      if (action === "search") {
        opts = $.extend(opts, {
          data: obj
        });
      } else {
        opts = $.extend(opts, {
          data: obj && this._dataFor(obj),
          contentType: "application/json; charset=utf-8"
        });
      }
      return opts;
    };
    Store.prototype._urlFor = function(action, id) {
      var replaceWith, url;
      replaceWith = id != null ? '/' + id : '';
      url = this.options.prefix || '/';
      url += this.options.urls[action];
      url = url.replace(/\/:id/, replaceWith);
      return url;
    };
    Store.prototype._methodFor = function(action) {
      var table;
      table = {
        'create': 'POST',
        'read': 'GET',
        'update': 'PUT',
        'destroy': 'DELETE',
        'search': 'GET'
      };
      return table[action];
    };
    Store.prototype._dataFor = function(annotation) {
      var data, highlights;
      highlights = annotation.highlights;
      delete annotation.highlights;
      $.extend(annotation, this.options.annotationData);
      data = JSON.stringify(annotation);
      if (highlights) {
        annotation.highlights = highlights;
      }
      return data;
    };
    Store.prototype._onBeforeSend = function(xhr) {
      var headers, key, val, _results;
      headers = this.element.data('annotator:headers');
      if (headers) {
        _results = [];
        for (key in headers) {
          val = headers[key];
          _results.push(xhr.setRequestHeader(key, val));
        }
        return _results;
      }
    };
    Store.prototype._onError = function(xhr) {
      var action, message;
      action = xhr._action;
      message = "Sorry we could not " + action + " this annotation";
      if (xhr._action === 'search') {
        message = "Sorry we could not search the store for annotations";
      } else if (xhr._action === 'read' && !xhr._id) {
        message = "Sorry we could not " + action + " the annotations from the store";
      }
      switch (xhr.status) {
        case 401:
          message = "Sorry you are not allowed to " + action + " this annotation";
          break;
        case 404:
          message = "Sorry we could not connect to the annotations store";
          break;
        case 500:
          message = "Sorry something went wrong with the annotation store";
      }
      Annotator.showNotification(message, Annotator.Notification.ERROR);
      return console.error("API request failed: '" + xhr.status + "'");
    };
    return Store;
  })();
}).call(this);
